// 2016 solution linearly 

// What is OOP ? Describe the basic characteristics of OOP., Mention any 3 drawbacks of prod=cedural programming.
// Ans - 
// OOP is a programming paradigm based on the concept of "objects", which can contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods.
// Characteristics of OOP -
//  1. Encapsulation 2. Abstraction 3. Inheritance 4. Polymorphism
// Drawbacks of procedural programming -
//  1. Difficult to maintain 2. Difficult to extend 3. Difficult to reuse 4. Difficult to debug


// Discuss the importance and limitation of inline function.
// Ans - The inline function is a function that is expanded in line when it is called. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inl
// ine function  is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the
// compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the
// function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place of the function call. The compiler can ignore the inline request and can choose not to expand the function body. The inline function is a request to the compiler to expand the function body in place    
// importance of inline functions are:
// 1. Inline functions are used to reduce the function call overhead.

// limitations of inline functions are:
// 1. Inline functions are not allowed to have static variables.
// 2. Inline functions are not allowed to have loops and switch statements.
// 3. Inline functions are not allowed to have goto statements.
// 4. Inline functions are not allowed to have static variables.
// 5. Inline functions are not allowed to have recursive calls.

// define type casting with an example. Discuss constant pointer and pointer to a constant with example
// type casting is the process of converting a variable from one data type to another data type. 
// type casting is done by using the following syntax:
// (type) expression
// type is the data type to which the expression is to be converted to.

// example:
#include <stdio.h>
int main()
{
    int a = 10;
    float b = 10.5;
    printf("a = %d  b = %f  ", a, b);
    printf("a = %f  b = %d  ", (float)a, (int)b);
    return 0;
}

// constant pointer is a pointer that points to a constant variable. 
// constant pointer is declared as follows: 
// type * const pointer_name = &variable_name;
// pointer_name is a constant pointer that points to a constant variable. 
// the value of the variable pointed by the constant pointer cannot be changed. 

// example:
#include <stdio.h>
int main()
{
    int * const p; // invalid declaration of constant pointer p 
    int a =20, b =50; // valid declaration of a and b 
    p = &a; // valid assignment of address of a to p 
    int a = 20, b = 50; // valid declaration of a and b
    int &const p =&a; // invalid declaration of constant pointer p 
    return 0;
}

// pointer to a constant is a pointer that points to a constant variable.
// pointer to a constant is declared as follows:
// const type * pointer_name = &variable_name;

// example:
#include <stdio.h>
int main()
{
    int a = 20, b = 50; // valid declaration of a and b
    int const * p = &a; // valid declaration of pointer p
    cout<<"a="<<*p<<endl;
    p = &b; // valid assignment of address of b to p
    cout<<"b="<<*p<<endl;
    return 0;
}



// constrruct an overloaded function equivalent to the pow(x,n) where x can be either integer or float and n is integer
// example:
#include <stdio.h>
int power(int x, int n)
{
    int i, p = 1;
    for (i = 1; i <= n; i++)
        p = p * x;
    return p;
}
float power(float x, int n)
{
    int i;
    float p = 1;
    for (i = 1; i <= n; i++)
        p = p * x;
    return p;
}
int main()
{
    int x, n;
    printf("Enter the value of x and n: ");
    scanf("%d %d", &x, &n);
    printf("x^n = %d", power(x, n));
    printf("x^n = %f", power((float)x, n));
    return 0;
}

// what is overloaded function -> function with same name but different parameters is called overloaded function 


// write a program to find the sum of the series 1/1! + 2/2! + 3/3! + 4/4! + 5/5! + 6/6! + 7/7! + 8/8! + 9/9! + 10/10!
// example:
#include <stdio.h>
int main()
{
    int i, j, fact; // fact is the factorial of i 
    float sum = 0;
    for (i = 1; i <= 10; i++) // calculating sum of the series
    {
        fact = 1; // factorial of 0 is 1 
        for (j = 1; j <= i; j++) // calculating factorial of i
            fact = fact * j;
        sum = sum + (float)i / fact; // adding the term to the sum 
    }
    printf("Sum of the series = %f", sum);
    return 0;
}
// output: Sum of the series = 2.718282


// What are friend functions? Explain with example
// friend functions are the functions that are declared as friend of a class. 
// friend functions are declared as follows:
// friend return_type function_name (argument list);
// friend functions are not the member functions of the class.
// friend functions can access the private and protected members of the class.
// friend functions can be declared inside the class or outside the class.
// friend functions can be declared using the scope resolution operator ::.
// friend functions can be declared using the keyword friend.

// example:
#include <stdio.h>
class complex
{
    int a, b;
    public:
        void set_data(int x, int y)
        {
            a = x;
            b = y;
        }
        void show_data()
        {
            printf("a = %d  b = %d  ", a, b);
        }
        friend void fun(complex); // friend function declaration
};
void fun(complex c) // friend function definition
{
    printf("a = %d  b = %d  ", c.a, c.b);
}
int main()
{
    complex c1;
    c1.set_data(3, 4);
    c1.show_data();
    fun(c1); // calling friend function
    return 0;
}

// What do you mean by function overriding? Explain with example
// function overriding is the process of redefining the inherited member function of the base class in the derived class. 

// EXAMPLE:
#include <stdio.h>
class base
{
    public:
        void show()
        {
            printf("Base class");
        }
};
class derived: public base
{
    public:
        void show()
        {
            printf("Derived class");
        }
};
int main()
{
    derived d;
    d.show();
    return 0;
}

// Explain copy constructor in cpp, why destructure function required in class  
// copy constructor is the constructor that is used to initialize an object using another object of the same class. 
// copy constructor is called when an object is initialized using another object of the same class.

// example:
#include <stdio.h>
class complex
{
    int a, b;
    public:
        complex(int x, int y) // parameterized constructor
        {
            a = x;
            b = y;
        }
        complex(complex &c) // copy constructor
        {
            a = c.a;
            b = c.b;
        }
        void show_data()
        {
            printf("a = %d  b = %d  ", a, b);
        }
};
int main()
{
    complex c1(3, 4), c2(c1); // c2 is initialized using c1
    c1.show_data();
    c2.show_data();
    return 0;
}

// destructor is the member function of the class that is automatically called when the object of the class goes out of scope. 
// destructor is used to release the memory allocated to the object of the class.


// example:
#include <stdio.h>
class complex
{
    int a, b;
    public:
        complex(int x, int y) // parameterized constructor
        {
            a = x;
            b = y;
        }
        ~complex() // destructor
        {
            printf("Destructor called");
        }
        void show_data()
        {
            printf("a = %d  b = %d  ", a, b);
        }
};
int main()
{
    complex c1(3, 4);
    c1.show_data();
    return 0;
}

// What do you mean by static variable and static function? Explain with example
// static variable is the variable that is declared as static. 
// static variable is declared as follows: 
// static data_type variable_name;
// static variable is initialized to zero by default.
// static variable is shared by all the objects of the class.
// static variable is declared inside the class but defined outside the class.
// static variable is declared using the scope resolution operator ::.

// example:
#include <stdio.h>
class complex
{
    int a, b;
    static int count; // static variable declaration
    public:
        void set_data(int x, int y)
        {
            a = x;
            b = y;
        }
        void show_data()
        {
            printf("a = %d  b = %d  ", a, b);
        }
        static void show_count() // static member function
        {
            printf("count = %d  ", count);
        }
};
int complex::count; // static variable definition
int main()
{
    complex c1, c2, c3;
    c1.set_data(3, 4);
    c2.set_data(5, 6);
    c3.set_data(7, 8);
    c1.show_data();
    c2.show_data();
    c3.show_data();
    complex::show_count(); // calling static member function
    return 0;
}

// static function is the function that is declared as static.
// static function is declared as follows:
// static return_type function_name (argument list);
// static function is not the member function of the class.
// static function can access the static members of the class.
// static function can be declared inside the class or outside the class.
// static function can be declared using the scope resolution operator ::.
// static function can be declared using the keyword static.

// example:
#include <stdio.h>
class complex
{
    int a, b;
    static int count; // static variable declaration
    public:
        void set_data(int x, int y)
        {
            a = x;
            b = y;
        }
        void show_data()
        {
            printf("a = %d  b = %d  ", a, b);
        }
        static void show_count() // static member function
        {
            printf("count = %d  ", count);
        }
};
int complex::count; // static variable definition
int main()
{
    complex c1, c2, c3;
    c1.set_data(3, 4);
    c2.set_data(5, 6);
    c3.set_data(7, 8);
    c1.show_data();
    c2.show_data();
    c3.show_data();
    complex::show_count(); // calling static member function
    return 0;
}   


// Define a class ACCOUNT that includes 10 following members: Data Members: Name of Fepositor, Account no, Type of A/C, Balance Amount
// Member Functions: To assign initial values, To deposit an amount, To withdraw an amount, To display name and balance.

// example:
#include <stdio.h>
#include <string.h>
class account
{
    char name[20];
    int acc_no;
    char type[10];
    float balance;
    public:
        void assign(char *n, int a, char *t, float b)
        {
            strcpy(name, n);
            acc_no = a;
            strcpy(type, t);
            balance = b;
        }
        void deposit(float amt)
        {
            balance += amt;
        }
        void withdraw(float amt)
        {
            balance -= amt;
        }
        void display()
        {
            printf("Name = %s  Acc no = %d  Type = %s  Balance = %f  ", name, acc_no, type, balance);
        }
};
int main()
{
    account a1;
    a1.assign("Anish", 123, "Savings", 10000);
    a1.deposit(5000);
    a1.withdraw(2000);
    a1.display();
    return 0;
}


// Differentiate between early and late binding
// early binding is the binding of the function call to the function definition at the compile time.
// early binding is also known as static binding.


// example:
#include <stdio.h>
class base
{
    public:
        void show()
        {
            printf("Base class");
        }
};
class derived: public base
{
    public:
        void show()
        {
            printf("Derived class");
        }
};
int main()
{
    derived d;
    d.show();
    return 0;
}

// late binding is the binding of the function call to the function definition at the run time.
// late binding is also known as dynamic binding.

// example:
#include <stdio.h>
class base
{
    public:
        virtual void show()
        {
            printf("Base class");
        }
};
class derived: public base
{
    public:
        void show()
        {
            printf("Derived class");
        }
};
int main()
{
    base *b;
    derived d;
    b = &d;
    b->show();
    return 0;
}

// What do you mean by operator overloading? Explain with example, Write a program  to overload the unary minus operator using frined function
// operator overloading is the process of making the operator to perform the user defined operations. 
// operator overloading is done by defining the function with the same name as the operator.
// operator overloading is done by using the keyword friend.
// operator overloading is done by using the keyword operator.

// example:
#include <stdio.h>
class complex
{
    int a, b;
    public:
        void set_data(int x, int y)
        {
            a = x;
            b = y;
        }
        void show_data()
        {
            printf("a = %d  b = %d  ", a, b);
        }
        friend complex operator-(complex); // friend function declaration
};
complex operator-(complex c) // friend function definition
{
    complex temp;
    temp.a = -c.a;
    temp.b = -c.b;
    return temp;
}
int main()
{
    complex c1, c2;
    c1.set_data(3, 4);
    c2 = -c1; // unary minus operator overloading
    c2.show_data();
    return 0;
}

// list out the operator that can't be overloaded in cpp
// the operator that can't be overloaded in cpp are:
// . (dot) operator
// :: (scope resolution) operator
// sizeof operator
// ?: (conditional) operator
// .*, ->* (pointer to member) operator

// define multiple inheritance with its syntax . WAP to demonstrate the use of constrictor in derived class
// multiple inheritance is the inheritance of the properties of more than one base class. 
// multiple inheritance is done by using the comma (,) operator.
// multiple inheritance is done by using the keyword virtual.

// example:
#include <stdio.h>
class base1
{
    public:
        base1()
        {
            printf("Base1 class constructor");
        }
};
class base2
{
    public:
        base2()
        {
            printf("Base2 class constructor");
        }
};
class derived: public base1, public base2
{
    public:
        derived()
        {
            printf("Derived class constructor");
        }
};
int main()
{
    derived d;
    return 0;
}



// what is  difference between virtual function and pure virtual function
// virtual function is the function that is declared using the keyword virtual. 

// example:
#include <stdio.h>
class base
{
    public:
        virtual void show()
        {
            printf("Base class");
        }
};
class derived: public base
{
    public:
        void show()
        {
            printf("Derived class");
        }
};

// pure virtual function is the function that is declared using the keyword virtual and = 0.

// example:
#include <stdio.h>
class base
{
    public:
        virtual void show() = 0;
};
class derived: public base
{
    public:
        void show()
        {
            printf("Derived class");
        }
};
int main(){
    derived d;
    d.show();
    return 0;
}


// what do you mean by exception handling? Explain with example
// exception handling is the process of handling the errors in the program. 
// exception handling is done by using the keyword try, catch and throw.

// example:
#include <stdio.h>
int main()
{
    int a, b;
    printf("Enter two numbers: ");
    scanf("%d %d", &a, &b);
    try
    {
        if(b == 0) // if b is zero then throw an exception
        {
            throw 0;
        }
        else
        {
            printf("Division = %d", a/b);
        }
    }
    catch(int i)
    {
        printf("Division by zero is not possible");
    }
    return 0;
}


// WAP which asks for a file name from the keyboard, opens a file with that name for output , reads a line from the keyboard character by character and writes the line onto the file
// example:
#include <stdio.h>
int main()
{
    FILE *fp; // file pointer declaration
    char ch, fname[20]; // character variable declaration
    printf("Enter file name: ");
    scanf("%s", fname);
    fp = fopen(fname, "w"); // file open for writing
    printf("Enter data: "); // data input from the keyboard
    while((ch = getchar()) != EOF) // EOF is the end of file character
    {
        fputc(ch, fp); // data written to the file
    }
    fclose(fp); // file close
    return 0;
}


// what is stream in c++? Explain with example
// stream is the sequence of characters. 
// stream is used to transfer the data from one place to another place.

// example:
#include <stdio.h>
int main()
{
    FILE *fp; // file pointer declaration
    char ch, fname[20]; // character variable declaration
    printf("Enter file name: ");
    scanf("%s", fname);
    fp = fopen(fname, "r"); // file open for reading
    printf("Data: "); // data output to the screen
    while((ch = fgetc(fp)) != EOF) // EOF is the end of file character
    {
        printf("%c", ch); // data read from the file
    }
    fclose(fp); // file close
    return 0;
}

// describe input/output class hierarchy in brief
// input/output class hierarchy is the class hierarchy that is used to perform the input/output operations. 
// input/output class hierarchy is the class hierarchy that is used to perform the file operations.

// example:
#include <stdio.h>
int main()
{
    FILE *fp; // file pointer declaration
    char ch, fname[20]; // character variable declaration
    printf("Enter file name: ");
    scanf("%s", fname);
    fp = fopen(fname, "w"); // file open for writing
    printf("Enter data: "); // data input from the keyboard
    while((ch = getchar()) != EOF) // EOF is the end of file character
    {
        fputc(ch, fp); // data written to the file
    }
    fclose(fp); // file close
    return 0;
}

// x/what is template function to find the maxi from template array of size N/
// template function is the function that is used to perform the operations on the different data types.
// template function is used to perform the operations on the different data types.

// example
#include <iostream>
using namespace std;
template <class T>
T maxi(T a, T b)
{
    return (a > b) ? a : b;
}
int main()
{
    cout << maxi(3, 7) << endl;
    cout << maxi(3.0, 7.0) << endl;
    cout << maxi('g', 'e') << endl;
    return 0;
}
